---
title: "Behavioural genetics analysis of social isolation (Cholesky)"
output:  
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    highlight: monochrome
    theme: flatly
    code_folding: hide
    includes:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      prompt = FALSE,
                      cache = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'asis')

options(bitmapType = 'quartz') # to render fonts better
```

```{r Clear global environment, include=FALSE}
remove(list = ls())
```

```{r Load packages, include=FALSE}
library(knitr)
library(haven)
library(psych)   
library(OpenMx)
library(tidyr)
library(tidyverse)
library(dplyr) #conflicts with tidyverse for e.g. rename and row_number
```

```{r source the data file path, include=FALSE}
# source raw data directory
source("../isolation_mentalhealth_data_path.R")
```

```{r read in dta data file}
dat.raw <- read_dta(paste0(data_path_raw, "Katie_23Sep22.dta"))
colnames(dat.raw)
```

**This is using the total score for social isolation (mother and teacher report combined). We will need to think about if this should be done for mother and teacher report separately.** 

# Data prep

```{r select variables needed}
dat <- dat.raw %>%
  dplyr::select(
         atwinid,
         btwinid,
         familyid,
         rorderp5,
         torder,
         zygosity,
         sampsex,
         seswq35,
         sethnic,
         sisoe5,
         sisoe7,
         sisoe10,
         sisoe12,
         sisoy5,
         sisoy7,
         sisoy10,
         sisoy12
  )

colnames(dat)
```

## Recode variables into factors

```{r recode sex}
dat <- dat %>%
  mutate(
    sex = 
      recode_factor(as_factor(sampsex),
        "1" = "Male",
        "2" = "Female"))

table(dat$sex)
```

```{r recode SES}
dat <- dat %>%
  mutate(
    ses = 
      recode_factor(as_factor(seswq35),
        "1" = "Low",
        "2" = "Middle", 
        "3" = "High"))

table(dat$ses)
```

```{r recode zygosity}
dat <- dat %>%
  mutate(
    zygosity = 
      recode_factor(as_factor(zygosity),
        "1" = "MZ",
        "2" = "DZ"))

table(dat$zygosity)
```

```{r recode ethnicity variable}
dat <- dat %>%
  mutate(
    ethnicity = 
      recode_factor(as_factor(sethnic),
        "1" = "White",
        "2" = "Asian", 
        "3" = "Black",
        "4" = "Mixed race",
        "5" = "Other"))

table(dat$ethnicity)
```

## Create variables as numeric versions

```{r create numeric isolation variables}
dat <- dat %>%
  mutate(
    sisoe5 = as.numeric(sisoe5),      # isolation elder
    sisoe7 = as.numeric(sisoe7),
    sisoe10 = as.numeric(sisoe10),
    sisoe12 = as.numeric(sisoe12),
    sisoy5 = as.numeric(sisoy5),      # isolation younger
    sisoy7 = as.numeric(sisoy7),
    sisoy10 = as.numeric(sisoy10),
    sisoy12 = as.numeric(sisoy12)
  )
colnames(dat)
```

## Creating the twin dataset

```{r remove variables not needed}
dat <- dat %>% select(
      -c(sampsex, 
         seswq35)
         )
colnames(dat)
```

To remove the double entry in the data, we will remove everyone who has a "random twin order" variable of 0. This will then remove any birth order effects. 

```{r remove one twin pair row}
dat.twin <- dat %>% filter(rorderp5 == "1")
```

```{r datasets for MZ and DZ}
# with all data to check numbers
dat.MZ <- dat %>% filter(zygosity == "MZ")
dat.DZ <- dat %>% filter (zygosity == "DZ")

# twin layout
dat.twin.MZ <- dat.twin %>% filter(zygosity == "MZ")
dat.twin.DZ <- dat.twin %>% filter (zygosity == "DZ")
```

```{r describe MZ and DZ data}
MZ_summary <- describe(dat.twin.MZ, 
                       skew = FALSE, 
                       range = FALSE)
MZ_summary

DZ_summary <- describe(dat.twin.DZ, 
                       skew = FALSE, 
                       range = FALSE)
DZ_summary
```

# MZ and DZ phenotypic correlation matrices

```{r select variables for correlations}
selvars <- c("sisoe5", "sisoe7", "sisoe10", "sisoe12", "sisoy5", "sisoy7", "sisoy10", "sisoy12")
```

Need to check the within-twin MZ and DZ phenotypic correlations (rmz, rdz) of each phenotype (correlations between elder and younger twin for each phenotype)

The rule of thumb is: 

 - if 2*rdz>rmz, choose an ACE model; 
 - if 2*rdz<rmz, choose a ADE model
 

```{r MZ matrices}
# covariance matrix
covar.mz <- cov(dat.twin.MZ[, selvars], use = "complete")

# correlation matrix (standardized covariance)
cor.mz <- cor(dat.twin.MZ[, selvars], use = "complete")
round(cor.mz, 3)
```

```{r DZ matrices}
# covariance matrix
covar.dz <- cov(dat.twin.DZ[, selvars], use = "complete")

# correlation matrix (standardized covariance)
cor.dz <- cor(dat.twin.DZ[, selvars], use = "complete")
round(cor.dz, 3)
```

Social isolation age 5: 

- rMZ = 0.585
- rDZ = 0.056 *seems low?*
- 2*rDZ = 0.112
- 0.112<0.585 = ADE*?*

Social isolation age 7: 

- rMZ = 0.444
- rDZ = 0.159 
- 2*rDZ = 0.318
- 0.318<0.444 = ADE*?*

Social isolation age 10: 

- rMZ = 0.453
- rDZ = 0.174 
- 2*rDZ = 0.348
- 0.348<0.453 = ADE*?*

Social isolation age 12: 

- rMZ = 0.453
- rDZ = 0.110 
- 2*rDZ = 0.220
- 0.220<0.453 = ADE*?*

**As the MZ correlations are relatively low for a dominance effect, it suggests here that an AE would be the way to go - so that A captures all additive and dominant genetic effects.**

Using Falconer's equations, we can obtain preliminary estimates of the standardized A, C, E variance components. 

VA = 2*rmz-rdz
VC = 1-VA+VE
VE= 1-rmz

VA = 2*0.59-0.056 = 1.068
VC = 1- 1.068 + 0.41 = -0.4789
VE = 1 - 0.59 = 0.41

As C is negative here, it's likely that the OpenMX model will give a very small estimate for C and that C will be dropped from the ACE model. The power to detect C is very low, to detect a C2 of 10% with a h2 of 60% requires 2200 MZ and DZ pairs. However, when deciding on an AE model, any C that does exist will fall into A and you will get an inflated heritability estimate. 

***

Below is not needed for analyses - but showing another way to get matrices. 

```{r express covariance matrix using SD and correlations}
# variances from covariance matrix - diagonal is one variable with itself
var.mz <- diag(covar.mz) 

# creating the standard deviation into a vector (sd is the square root of the variance) then put this into a matrix
sd.mz <- diag(sqrt(var.mz))

# re-calculating variance of MZ 
Smz <- sd.mz%*%cor.mz%*%t(sd.mz) 
round(covar.mz - Smz, 3) # compare with previous calculation

# Therefore, we can also obtain the correlation matrix as follows
rMZ <- cov2cor(covar.mz)
```

***

# Cholesky fitting

```{r number of variables (phenotypes)}
nv	<- 4			# number of variables for a twin 
ntv	<- 2*nv		# number of variables for a pair 
```

## Saturated model

#### Parameter labels

**Labels for variables:**

The correlations should reflect all in the matrix that are not 1 and below/above the diagonal, an example of the labeling is below:

      xph   = cross phenotype/variable/trait
      xt    = cross twin
      xtxph = cross twin cross phenotype

2x2 matrix:
        sisoe5  sisoe7  sisoy5 sisoy7
sisoe5  1.000      
sisoe7  xph1    1.000    
sisoy5  xt1     xtxph2  1.000  
sisoy7  xtxph1  xt2     xph2   1.000

Full 4x4 correlation matrix:
         sisoe5   sisoe7   sisoe10  sisoe12  sisoy5  sisoy7  sisoy10  sisoy12
sisoe5   1.000   
sisoe7   xph1    1.000   
sisoe10  xph2    xph4     1.000   
sisoe12  xph3    xph5     xph6     1.000 
sisoy5   xt1     xtxph4   xtxph7   xtxph10  1.000  
sisoy7   xtxph1  xt2      xtxph8   xtxph11  xph7   1.000   
sisoy10  xtxph2  xtxph5   xt3      xtxph12  xph8   xph10   1.000  
sisoy12  xtxph3  xtxph6   xtxph9   xt4      xph9   xph11   xph12   1.000

First we need to specify the start values and labels to make the code less busy. For the start values, I used the summary tables to check the approximate value the model should be looking for. The list should reflect the same order that you have in selvars. 

```{r specify saturated model}
# start values
svM	  <- c(0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7)	  # means               
svSD  <- c(1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1)    # standard deviations
svRmz <- c(rep(0.3, 28))                    # correlations for MZ - 28 correlations in total
svRdz <- c(rep(0.15, 28))                   # correlations for DZ 

# labels
labMZm	<- c("MZme5", "MZme7", "MZme10", "MZme12", "MZmy5", "MZmy7", "MZmy10", "MZmy12")	         # MZ means       
labDZm	<- c("DZme5", "DZme7", "DZme10", "DZme12", "DZmy5", "DZmy7", "DZmy10", "DZmy12")           # DZ means

labMZsd	<- c("MZsde5", "MZsde7", "MZsde10", "MZsde12", "MZsdy5", "MZsdy7", "MZsdy10", "MZsdy12")   # MZ standard deviations
labDZsd	<- c("DZsde5", "DZsde7", "DZsde10", "DZsde12", "DZsdy5", "DZsdy7", "DZsdy10", "DZsdy12")   # DZ standard deviations

labMZr	<- c("MZrxph1", "MZrxph2", "MZrxph3", "MZrxt1",	"MZrxtxph1", "MZrxtxph2", "MZrxtxph3",     # MZ correlations
            "MZrxph4", "MZrxph5", "MZrxtxph4", "MZrxt2", "MZrxtxph5", "MZrxtxph6", 
            "MZrxph6", "MZrxtxph7", "MZrxtxph8", "MZrxt3", "MZrxtxph9",
            "MZrxtxph10", "MZrxtxph11", "MZrxtxph12", "MZrxt4",
            "MZrxph7", "MZrxph8", "MZrxph9", 
            "MZrxph10", "MZrxph11",
            "MZrxph12")     
labDZr	<- c("DZrxph1", "DZrxph2", "DZrxph3", "DZrxt1",	"DZrxtxph1", "DZrxtxph2", "DZrxtxph3",     # DZ correlations
            "DZrxph4", "DZrxph5", "DZrxtxph4", "DZrxt2", "DZrxtxph5", "DZrxtxph6", 
            "DZrxph6", "DZrxtxph7", "DZrxtxph8", "DZrxt3", "DZrxtxph9",
            "DZrxtxph10", "DZrxtxph11", "DZrxtxph12", "DZrxt4",
            "DZrxph7", "DZrxph8", "DZrxph9", 
            "DZrxph10", "DZrxph11",
            "DZrxph12") 
```

#### Matrices

```{r matrices for saturated free parameters (means, sd, cor)}
# MZ
meanMZ	<- mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM,	labels = labMZm, name = "ExpMeanMZ")
sdMZ		<- mxMatrix(type = "Diag", nrow = ntv, ncol = ntv, free = TRUE, values = svSD,	labels = labMZsd, name = "sdMZ")
corMZ		<- mxMatrix(type = "Stand", nrow = ntv, ncol = ntv, free = TRUE, values = svRmz, labels = labMZr,	name = "corMZ") 

# DZ
meanDZ	<- mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM,	labels = labDZm, name = "ExpMeanDZ")
sdDZ		<- mxMatrix(type = "Diag", nrow = ntv, ncol = ntv, free = TRUE, values = svSD,	labels = labDZsd, name = "sdDZ")
corDZ		<- mxMatrix(type = "Stand", nrow = ntv, ncol = ntv, free = TRUE, values = svRdz, labels = labDZr,	name = "corDZ") 
```

#### Alegbra 

This is the same matrix algebra that is calculated above from the Boulder workshop code:

            covariace = SD * r * t(SD) 

%*% is matrix multiplication
t() is transpose
full list of operators [here](https://openmx.ssri.psu.edu/wiki/matrix-operators-and-functions) 

The result matrix of the matrix algebra calculation S*R*S’ is the Symmetric Variance-Covariance matrix of the model, with the expected Variance of the Twin 1 variable on the 1st Diagonal Element, the expected Variance of the Twin 2 variable on the 2nd  Diagonal Element and the Covariance on the off-diagonal. Since we are dealing with two types of Twin pairs, we will specify a different S and R matrix for MZ and DZ pairs and fit a separate Saturated model to each of the sub-data files, the MZ data and the DZ data. 

```{r Algebra for saturated expected variance/covariance matrices for MZ and DZ pairs}
covMZ	<- mxAlgebra(expression = sdMZ %*% corMZ %*% t(sdMZ), name = "ExpCovMZ")
covDZ	<- mxAlgebra(expression = sdDZ %*% corDZ %*% t(sdDZ), name = "ExpCovDZ")
```

```{r specify saturated data objects to be saved in openMx format}
datMZ <- mxData(observed = dat.twin.MZ, type = "raw")
datDZ <- mxData(observed = dat.twin.DZ, type = "raw")
```

```{r create saturated objectives}
# Objective objects 
objMZ <- mxExpectationNormal(covariance = "ExpCovMZ", means = "ExpMeanMZ", dimnames = selvars)
objDZ <- mxExpectationNormal(covariance = "ExpCovDZ", means = "ExpMeanDZ", dimnames = selvars)
```

```{r fit function for all models}
fitFunction <- mxFitFunctionML()
```

#### Create the saturated model

```{r create saturated model}
# models for MZ and DZ
modelMZ	<- mxModel(meanMZ, sdMZ, corMZ, covMZ, datMZ, objMZ, fitFunction, name = "MZ")
modelDZ	<- mxModel(meanDZ, sdDZ, corDZ, covDZ, datDZ, objDZ, fitFunction, name = "DZ")

# estimation
minus2ll <- mxAlgebra(expression = MZ.objective + DZ.objective, name = "m2LL")
obj	<- mxFitFunctionAlgebra("m2LL")

# Saturated model 
SatModel <- mxModel("Sat", modelMZ, modelDZ, minus2ll, obj)
```

#### Saturated model output

The Saturated Model is represented by a path diagram. Using path tracing rules we will derive the expected model for the variance-covariance structure of the data. The goal of the saturated model is to obtain the best possible (maximum likelihood) estimation of the twin correlations and this is preferred over the correlations that you can typically get using R commands (also shown above). 

The cross-twin correlations (rxt) are expected to be different, and the cross-twin cross-trait (rxtxph) are expected to be different. However, the within-twin cross trait (rxph) are not supposed to differ for the elder and younger twins. 

```{r saturated model output}
# Run the saturated model
SatFit	<- mxRun(SatModel, intervals = FALSE)
(SatSumm	<- summary(SatFit))

# Generate SatModel Output so you could see the labels
SatFit$MZ.corMZ
SatFit$MZ.ExpCovMZ
SatFit$DZ.corDZ
SatFit$DZ.ExpCovDZ
```

The saturated model estimates the variances for the variables in MZ and DZ twin pairs, as well as the covariance in each group. The model provides a basis to test assumptions that are implicit in the ACE model:

- All variances should be non-significantly different
- We do not expect birth order nor zygosity effects on the variances
- Var1 = Var2 = Var3 = Var4 

The correlations estimated by optimizing the saturated Model using OpenMx correct for missingness. The saturated model also gives a baseline fit index (-2 * the likelihood, -2LL) for the observed data, to be used as a reference for comparison with the likelihood (-2LL) of the genetic models. 

### Saturated sub-model 1: Constrained correlation model (equal variances & means across twin order & zygosity group)

To manipulate  the parameters in matrices we wish to change in the full model, we use the 'omxSetParameters' function with the original 'labels' and 'newlabels' to indicate the changes, i.e. specifying the same label effectively constraints the parameters to be the same. 

Here we have equated means and variances across twin order and zygosity. Then created *one overall set of within-person cross-trait correlations and symmetric xtwin-xtrait correlation matrices in MZ and DZ groups*.  

Labeling:
        sisoe5  sisoe7  sisoy5 sisoy7
sisoe5  1.000      
sisoe7  xph     1.000    
sisoy5  xt1     xtxph   1.000  
sisoy7  xtxph   xt2     xph    1.000

The full matrix
         sisoe5   sisoe7   sisoe10  sisoe12     sisoy5  sisoy7  sisoy10  sisoy12
sisoe5   1.000   
sisoe7   xph1    1.000   
sisoe10  xph2    xph4     1.000   
sisoe12  xph3    xph5     xph6     1.000 

sisoy5   xt1     xtxph1   xtxph2   xtxph3       1.000  
sisoy7   xtxph1  xt2      xtxph4   xtxph5       xph1   1.000   
sisoy10  xtxph2  xtxph4   xt3      xtxph6       xph2   xph4   1.000  
sisoy12  xtxph3  xtxph5   xtxph6   xt4          xph3   xph5   xph6   1.000

```{r specify saturday submodel 1 new labels}
# start values
newsvRmz <- c(rep(0.3, 16))                    # correlations for MZ - 16 distinct correlations in total
newsvRdz <- c(rep(0.15, 16))                   # correlations for DZ 

# labels
newlabm	<- c("m5", "m7", "m10", "m12", "m5", "m7", "m10", "m12")	         # means       
newlabsd	<- c("sd5", "sd7", "sd10", "sd12", "sd5", "sd7", "sd10", "sd12") # standard deviations

newlabrMZ	<- c("rxph1", "rxph2", "rxph3", "MZrxt1",	"MZrxtxph1", "MZrxtxph2", "MZrxtxph3",     # MZ correlations
            "rxph4", "rxph5", "MZrxtxph1", "MZrxt2", "MZrxtxph4", "MZrxtxph5", 
            "rxph6", "MZrxtxph2", "MZrxtxph4", "MZrxt3", "MZrxtxph6",
            "MZrxtxph3", "MZrxtxph5", "MZrxtxph6", "MZrxt4",
            "rxph1", "rxph2", "rxph3", 
            "rxph4", "rxph5",
            "rxph6")  
newlabrDZ	<- c("rxph1", "rxph2", "rxph3", "DZrxt1",	"DZrxtxph1", "DZrxtxph2", "DZrxtxph3",     # DZ correlations
            "rxph4", "rxph5", "DZrxtxph1", "DZrxt2", "DZrxtxph4", "DZrxtxph5", 
            "rxph6", "DZrxtxph2", "DZrxtxph4", "DZrxt3", "DZrxtxph6",
            "DZrxtxph3", "DZrxtxph5", "DZrxtxph6", "DZrxt4",
            "rxph1", "rxph2", "rxph3", 
            "rxph4", "rxph5",
            "rxph6") 
```

```{r specify saturated submodel 1}
# create model 
Sub1Model	<- mxModel(SatModel, name = "Sub1")

# set parameters to be the same across 
# equal means
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svM, labels = labMZm, newlabels = newlabm)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svM, labels = labDZm, newlabels = newlabm)
# equal variances
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svSD, labels = labMZsd, newlabels = newlabsd)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svSD, labels = labDZsd, newlabels = newlabsd)
# equal correlations
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = newsvRmz, labels = labMZr, newlabels = newlabrMZ)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = newsvRdz, labels = labDZr, newlabels = newlabrDZ)

# for some reason it's the wrong number of starting values so to choose randomly I've set the below
Sub1Model <- omxAssignFirstParameters(Sub1Model)
```

```{r run saturated sub model 1}
Sub1Fit	<- mxRun(Sub1Model, intervals = TRUE)
(Sub1Summ	<- summary(Sub1Fit))
```

```{r submodel 1 output}
Sub1Fit$MZ.ExpCovMZ
Sub1Fit$MZ.MZCor
Sub1Fit$DZ.ExpCovDZ
Sub1Fit$DZ.DZCor

mxCompare(SatFit, Sub1Fit)
```

As the p-value is significant, the sub-model is significantly worse fit compared to the saturated model. Now we will constrain different aspects here to see where the inequality in variance is coming up. 

**INSERT HERE THE STEPS IN THE SATURATED MODEL LECTURE TO INDEPENDENTLY CONSTRAIN DIFFERENT PARTS OF THE MODEL (6 STEPS)** 

## ACE model

#### Matrices to estimate a, c, and e path coefficients

Here we have 4 variables (social isolation at ages 5, 7, 10, 12), so this will be a 4 by 4 matrix (I assume):
a11                            # path of genetic influence on time point 1
a21     a22                    # path of genetic influence on time point 2 (a21) plus new genetic influence at time point 2 (a22)
a31     a23     a33
a41     a24     a34      a44

The structure of the matrix we need for the Cholesky decomposition, is one where the first latent A, C and E factors (A1, C1 and E1) influence both variables, but the second factors (A2, C2 and E2) only influence the second variable. The matrix type that represents a factor loading I have just described, is type ‘Lower’. As you can see below, the factor loadings a11 and a21 and a22 follow a pattern where the matrix has the diagonal and lower elements, but the upper diagonal element is zero. 

                          A1    A2    A3    A4
Isolation age 5 Twin 1    a11   0     0     0
Isolation age 7 Twin 1    a21   a22   0     0
Isolation age 10 Twin 1   a31   a23   a33   0 
Isolation age 12 Twin 1   a41   a23   a34   a44

```{r ace matrices}
pathA	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(rep(0.5, 10)), labels = c("a11", "a21","a31","a41","a22","a23","a24","a33","a34","a44"), name = "a") 
pathC	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(rep(0.5, 10)), labels = c("c11", "c21","c31","c41","c22","c23","c24","c33","c34","c44"), name="c" )
pathE	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(rep(0.5, 10)), labels = c("e11", "e21","e31","e41","e22","e23","e24","e33","e34","e44"), name="e" )
```

```{r matrix for the expected means}
MeanG	<-mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM, labels = newlabm, name = "ExpMean")
```

Then we want to compute the covariance matrix (V) which is the sum of the ACE variance components. 
Using the row-by-col multiplication of a and a transpose, we get the 4x4 A variance covariance matrix of the four variables. We do this multiplication for c and e as well to get the C and E Var/Cov matrix. We can then standardise them to get h2, c2, and e2. 

```{r algebra to generate A, C, E variance components}
# Non-standardized variance components
covA	<- mxAlgebra(expression = a %*% t(a), name = "A")
covC	<- mxAlgebra(expression = c %*% t(c), name = "C") 
covE	<- mxAlgebra(expression = e %*% t(e), name = "E")

# Standardized variance components
covP	<- mxAlgebra(expression = A + C + E, name = "V" ) # total variance
StA	<- mxAlgebra(expression = A/V, name = "h2")
StC	<- mxAlgebra(expression = C/V, name = "c2")
StE	<- mxAlgebra(expression = E/V, name = "e2")
```

The I*V bit below extracts the variances from the diagonal of the covariance matrix V, by multiplying element by element. 

To get the phenotypic correlations, we use the same procedure :

* Extract the variances, take the square root and invert the resulting matrix
* pre-and-post multiply this matrix with V, to get the correlation matrix (you should pre-and-post multiply the matrix with its transpose, but because the matrix is symmetrical its transpose is equal to itself)

For the A, C and E correlations it is the same process. Except this time we are multiplying the identity matrix with A (and then C and E), rather than V, and then pre-and-post multiply the resulting matrix with A (and then C and E) rather than V. 

Notes from Tim on when to hash these out: "Note that originally Ra and Rc were commented out, I think that's because if you include them, it causes problems when you run the submodels when A and C are dropped. Since we have got rid of the CE model in this script, we can un-comment A to get the correlation, but leave C commented out. Note that you also have to modify the pars statement if you add/remove these"

All chunks below with * are not included in Fruhling's script. 

Below we use the genetic Var/Cov matrix A to get the genetic correlation matrix with rA21 indicating the correlation between the A1 and A2 factors in the Bivariate model - **so does this give you the correlated factors solution? And not the Cholesky? Do we need this part of the script??**

```{r algebra to compute phenotypic ACE correlations}
matI <- mxMatrix(type = "Iden", nrow = nv, ncol = nv, name = "I")
matIsd <-mxAlgebra(solve(sqrt(I*V)), name = "isd")
rph	<- mxAlgebra(expression = solve(sqrt(I*V)) %*% V %*% solve(sqrt(I*V)), name = "Rph") # new identity matrix for standardising 
rA	<- mxAlgebra(expression = solve(sqrt(I*A)) %*% A %*% solve(sqrt(I*A)), name = "Ra")
rC	<- mxAlgebra(expression = solve(sqrt(I*C)) %*% C %*% solve(sqrt(I*C)), name = "Rc") # Hash this when running AE model
rE	<- mxAlgebra(expression = solve(sqrt(I*E)) %*% E %*% solve(sqrt(I*E)), name = "Re")
```

**here we need to understand why to have squared and unsquared**

```{r standardised cholesky parameters (unsquared) *}
Sta <- mxAlgebra(isd%*%a, name = "sta")
Stc <- mxAlgebra(isd%*%c, name = "stc")
Ste <- mxAlgebra(isd%*%e, name = "ste")
```

```{r standardised cholesky parameters (squared) *}
Sta2 <- mxAlgebra(sta*sta, name = "sta2")
Stc2 <- mxAlgebra(stc*stc, name = "stc2")
Ste2 <- mxAlgebra(ste*ste, name = "ste2")
```

```{r algebra to put standardised parameter estimates into a matrix with col and row labels *}
rowVars	<- rep('Vars', nv)
colVars	<- rep(c('h2', 'c2', 'e2'), each = nv)
estVars	<- mxAlgebra(expression = cbind(h2,c2,e2), name = "Est", dimnames = list(rowVars,colVars))
```

If you want to work out the amount of the phenotypic correlation that is due to A, C or E, you can use this dataframe. 

```{r algebra to compute Rph-A, Rph-C, and Rph-E between the two variables in a bivariate model (this would be different for more than two variables I guess)}
rphace <- mxAlgebra(expression = cbind((sqrt(h2[1,1])*Ra[2,1]*sqrt(h2[2,2])),
							(sqrt(c2[1,1])*Rc[2,1]*sqrt(c2[2,2])),
							(sqrt(e2[1,1])*Re[2,1]*sqrt(e2[2,2])) ), name = "RphACE" )
```

The A factors are correlated across twins either by 1 for MZ pairs or 0.5 for DZ pairs, whereas the C factors are correlated 1 for either type of pairs. In the univariate model we only had 1 A and C factors that correlated across twins, in the bivariate and above model we have to correlate both the A1 and A2 factors across twins and both the C1 and C2 factors across twins.

```{r algebra for expected variance/covariance matrices in MZ and DZ twins}
covMZ	<- mxAlgebra(expression = rbind(cbind(A+C+E, A+C),
                                          cbind(A+C, A+C+E)), name = "expCovMZ" )
covDZ	<- mxAlgebra(expression = rbind(cbind(A+C+E, 0.5%x%A+C),
                                          cbind(0.5%x%A+C, A+C+E)), name = "expCovDZ" )
```

```{r data objects for ACE - this is repetition from earlier?}
# data objects 
dataMZ <- mxData(observed = dat.twin.MZ, type = "raw")
dataDZ <- mxData(observed = dat.twin.DZ, type = "raw")
```

```{r objective objects - here this is a different mx command to Tim - this is repetition from earlier?}
# Tim uses mxFIMLObjective() here
objMZ	<- mxExpectationNormal(covariance = "expCovMZ", means = "ExpMean", dimnames = selvars)
objDZ	<- mxExpectationNormal(covariance = "expCovDZ", means = "ExpMean", dimnames = selvars)
```

***
No idea if how I am specifying the confidence intervals for the 4 variable model are correct????
***

```{r ACE model estimation}
# all parameters to be estimated 
pars <- list(pathA, pathC, pathE, covA, covC, covE, covP, StA, StC, StE, matI, rph, rA, rE, MeanG, estVars, matIsd, Sta, Sta2, Stc, Stc2, Ste, Ste2)

# add these to the model for MZ and DZ with the matrices we have created
modelMZ	<- mxModel(pars, covMZ, dataMZ, objMZ, fitFunction, name = "MZ")
modelDZ	<- mxModel(pars, covDZ, dataDZ, objDZ, fitFunction, name = "DZ")

# fitting
minus2ll <- mxAlgebra(expression = MZ.objective + DZ.objective, name = "m2LL")
obj <- mxFitFunctionAlgebra("m2LL")

# confidence intervals - not sure if this is the right adaptation for 4 variable model
Conf1 <- mxCI(c('h2[1,1]', 'h2[2,2]','h2[3,3]', 'h2[4,4]', 'c2[1,1]', 'c2[2,2]', 'c2[3,3]', 'c2[4,4]', 'e2[1,1]', 'e2[2,2]', 'e2[3,3]', 'e2[4,4]')) # here you can see if you should drop C from the model
# Conf2	<- mxCI(c('Rph[2,1]', 'Ra[2,1]', 'Rc[2,1]', 'Re[2,1]')) # not sure how to label these?
# how am I supposed to know what the below need to be?
#Conf3	<- mxCI(c('sta2[3,2]', 'stc2[3,2]', 'ste2[3,2]', 'sta2[3,1]', 'stc2[3,1]', 'ste2[3,1]', 'sta2[2,1]', 'stc2[2,1]', 'ste2[2,1]', 'sta2[4,2]', 'stc2[4,2]', 'ste2[4,2]'), 'sta2[4,1]', 'stc2[4,1]', 'ste2[4,1]', 'sta2[4,3]', 'stc2[4,3]', 'ste2[4,3]')
Conf4	<- mxCI(c('sta2[1,1]', 'stc2[1,1]', 'ste2[1,1]', 'sta2[2,2]', 'stc2[2,2]', 'ste2[2,2]', 'sta2[3,3]', 'stc2[3,3]', 'ste2[3,3]', 'sta2[4,4]', 'stc2[4,4]', 'ste2[4,4]'))
Conf5	<- mxCI(c('h2', 'c2', 'e2'))

# full model
AceModel <- mxModel("ACE", pars, modelMZ, modelDZ, minus2ll, obj 
                   # Conf1, Conf3
                    )
```

```{r run ACE model}
AceFit <- mxRun(AceModel, intervals = TRUE)

AceSumm  <- summary(AceFit)
AceSumm

round(AceFit@output$estimate,4)
round(AceFit$Est@result,4)
```

**I don't quite understand what output we need - need Tim to help explain this**

```{r ACE model output}
# proportion of individual differences explained by A, C, and E for each phenotype
AceFit$ACE.h2 # heritability on the diagonal and then % of phenotypic that is genetic on off-diagonal
AceFit$ACE.c2
AceFit$ACE.e2

# correlation between the A, C, and E factors between the traits? Isn't this for the correlated factors solution?
AceFit$ACE.Rph # total phenotypic correlation?
AceFit$ACE.Ra # correlations between the a factors
AceFit$ACE.Rc
AceFit$ACE.Re

# Are these the Cholesky paths? If so how do we interpret these? 
AceFit$ACE.sta
AceFit$ACE.sta2 # This is the cholesky diagonal path to a2 - can be interpreted as a % variance explained 
AceFit$ACE.stc
AceFit$ACE.stc2
AceFit$ACE.ste
AceFit$ACE.ste2

# output from Fruhling's code
round(mxEval(ACE.h2, AceFit), ) 
mxEval(ACE.c2, AceFit)
mxEval(ACE.e2, AceFit)
mxEval(ACE.Rph, AceFit)
mxEval(ACE.Ra, AceFit)
# mxEval(ACE.Rc, AceFit) # THE OUTPUT COULDN'T FIND THIS FOR SOME REASON
mxEval(ACE.Re, AceFit)
# mxEval(ACE.RphACE, AceFit) # THE OUTPUT COULDN'T FIND THIS FOR SOME REASON

# Compare the ACE model and saturated model 
mxCompare(SatFit, AceFit)
```

The ACE model fits significantly worse than the saturated model. 

h2 output mxEval(ACE.h2, AceFit)

      [,1]  [,2]  [,3]  [,4]
[1,] 0.563   
[2,] 0.664 0.496  
[3,] 0.787 0.744 0.489 
[4,] 0.846 0.720 0.680 0.447

**Is the above the same as the below?? Need to create the cholesky figure in powerpoint to see what this lokos like ** 

                           A1    A2    A3    A4
Isolation age 5 Twin 1    a11   0     0     0
Isolation age 7 Twin 1    a21   a22   0     0
Isolation age 10 Twin 1   a31   a23   a33   0 
Isolation age 12 Twin 1   a41   a23   a34   a44


***

NEXT STEPS

* Add in the 6 steps to see why the variance is not equal across zygosity and twin order
* Go through ACE and output - map out each of the matrices to see what each output is telling you - make a table for this and print off to have in the office. 
* tidy up ACE model and make more notes from GED avout what each bit means - especially for cholesky. 
* Cholesky matrices is the sta2 output - this is the diagnoal lines in the path tracing. 
* Run AE model by removing the rC estimation indicated above, and set the parameters to 0 as seen in Tim's script. 
* Interpret the AE output
*Email monika about getting the script for the overlap section of the paper
* Once finished AE model, tidy up the knitted file so that it shows all code but only important output matrices













