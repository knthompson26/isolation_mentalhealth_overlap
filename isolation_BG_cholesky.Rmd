---
title: "Behavioural genetics analysis of social isolation (Cholesky)"
output:  
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    highlight: monochrome
    theme: flatly
    code_folding: hide
    includes:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      prompt = FALSE,
                      cache = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'asis')

options(bitmapType = 'quartz') # to render fonts better
```

```{r Clear global environment, include=FALSE}
remove(list = ls())
```

```{r Load packages, include=FALSE}
library(knitr)
library(haven)
library(psych)   
library(OpenMx)
library(tidyr)
library(tidyverse)
library(dplyr) #conflicts with tidyverse for e.g. rename and row_number
```

```{r source the data file path, include=FALSE}
# source raw data directory
source("../isolation_mentalhealth_data_path.R")
```

```{r read in dta data file}
dat.raw <- read_dta(paste0(data_path_raw, "Katie_23Sep22.dta"))
colnames(dat.raw)
```

**This is using the total score for social isolation (mother and teacher report combined). We will need to think about if this should be done for mother and teacher report separately.** 

# Data prep

```{r select variables needed}
dat <- dat.raw %>%
  dplyr::select(
         atwinid,
         btwinid,
         familyid,
         rorderp5,
         torder,
         zygosity,
         sampsex,
         seswq35,
         sethnic,
         sisoe5,
         sisoe7,
         sisoe10,
         sisoe12,
         sisoy5,
         sisoy7,
         sisoy10,
         sisoy12
  )

colnames(dat)
```

## Recode variables into factors

```{r recode sex}
dat <- dat %>%
  mutate(
    sex = 
      recode_factor(as_factor(sampsex),
        "1" = "Male",
        "2" = "Female"))

table(dat$sex)
```

```{r recode SES}
dat <- dat %>%
  mutate(
    ses = 
      recode_factor(as_factor(seswq35),
        "1" = "Low",
        "2" = "Middle", 
        "3" = "High"))

table(dat$ses)
```

```{r recode zygosity}
dat <- dat %>%
  mutate(
    zygosity = 
      recode_factor(as_factor(zygosity),
        "1" = "MZ",
        "2" = "DZ"))

table(dat$zygosity)
```

```{r recode ethnicity variable}
dat <- dat %>%
  mutate(
    ethnicity = 
      recode_factor(as_factor(sethnic),
        "1" = "White",
        "2" = "Asian", 
        "3" = "Black",
        "4" = "Mixed race",
        "5" = "Other"))

table(dat$ethnicity)
```

## Create variables as numeric versions

```{r create numeric isolation variables}
dat <- dat %>%
  mutate(
    sisoe5 = as.numeric(sisoe5),      # isolation elder
    sisoe7 = as.numeric(sisoe7),
    sisoe10 = as.numeric(sisoe10),
    sisoe12 = as.numeric(sisoe12),
    sisoy5 = as.numeric(sisoy5),      # isolation younger
    sisoy7 = as.numeric(sisoy7),
    sisoy10 = as.numeric(sisoy10),
    sisoy12 = as.numeric(sisoy12)
  )
colnames(dat)
```

## Creating the twin dataset

```{r remove variables not needed}
dat <- dat %>% select(
      -c(sampsex, 
         seswq35)
         )
colnames(dat)
```

To remove the double entry in the data, we will remove everyone who has a "random twin order" variable of 0. This will then remove any birth order effects. 

```{r remove one twin pair row}
dat.twin <- dat %>% filter(rorderp5 == "1")
```

```{r datasets for MZ and DZ}
# with all data to check numbers
dat.MZ <- dat %>% filter(zygosity == "MZ")
dat.DZ <- dat %>% filter (zygosity == "DZ")

# twin layout
dat.twin.MZ <- dat.twin %>% filter(zygosity == "MZ")
dat.twin.DZ <- dat.twin %>% filter (zygosity == "DZ")
```

```{r describe MZ and DZ data}
MZ_summary <- describe(dat.twin.MZ, 
                       skew = FALSE, 
                       range = FALSE)
MZ_summary

DZ_summary <- describe(dat.twin.DZ, 
                       skew = FALSE, 
                       range = FALSE)
DZ_summary
```

# MZ and DZ phenotypic correlation matrices

```{r select variables for correlations}
selvars <- c("sisoe5", "sisoe7", "sisoe10", "sisoe12", "sisoy5", "sisoy7", "sisoy10", "sisoy12")
```

Need to check the within-twin MZ and DZ phenotypic correlations (rmz, rdz) of each phenotype (correlations between elder and younger twin for each phenotype)

The rule of thumb is: 
 - if 2*rdz>rmz, choose an ACE model; 
 - if 2*rdz<rmz, choose a ADE model
 
Social isolation age 5: 
- rMZ = 0.585
- rDZ = 0.056 *seems low?*
- 2*rDZ = 0.112
- 0.112<0.585 = ADE*?*

Social isolation age 7: 
- rMZ = 0.444
- rDZ = 0.159 
- 2*rDZ = 0.318
- 0.318<0.444 = ADE*?*

Social isolation age 10: 
- rMZ = 0.453
- rDZ = 0.174 
- 2*rDZ = 0.348
- 0.348<0.453 = ADE*?*

Social isolation age 12: 
- rMZ = 0.453
- rDZ = 0.110 
- 2*rDZ = 0.220
- 0.220<0.453 = ADE*?*

**surely this can't be right - ACE model would be the way to go here??**

Using Falconer's equations, we can obtain preliminary estimates of the standardized A, D, E variance components. 

For ADE:
VA = 4*rdz-rmz 
VD = 2*rmz-4*rdz
VE = 1-VA-VD

For ACE: *need to check this against my notes from boulder course*
VA = 2*rmz-rdz
VC = 1-VA+VE
VE= 1-rmz

```{r MZ matrices}
covar.mz <- cov(dat.twin.MZ[, selvars], use = "complete")
round(covar.mz, 3)

cor.mz <- cor(dat.twin.MZ[, selvars], use = "complete")
round(cor.mz, 3)
```

```{r DZ matrices}
covar.dz <- cov(dat.twin.DZ[, selvars], use = "complete")
round(covar.dz, 3)

cor.dz <- cor(dat.twin.DZ[, selvars], use = "complete")
round(cor.dz, 3)
```

Below is not needed for analyses - but showing another way to get matrices. 

```{r express covariance matrix using SD and correlations}
# variances from covariance matrix - diagonal is one variable with itself
var.mz <- diag(covar.mz) 
round(var.mz, 3)

# creating the standard deviation into a vector (sd is the square root of the variance) then put this into a matrix
sd.mz <- diag(sqrt(var.mz))
round(sd.mz, 3)

# re-calculating variance of MZ 
Smz <- sd.mz%*%cor.mz%*%t(sd.mz) 
round(Smz, 3)
round(covar.mz - Smz, 3) # compare with previous calculation

# Therefore, we can also obtain the correlation matrix as follows
rMZ = cov2cor(covar.mz)
round(rMZ, 3)
```


# Cholesky fitting

**AT THE MOMENT I DONT UNDERSTAND HOW TO MAKE THIS A CHOLESKY AND NOT THE STANDARD BIVARIATE WITH CORRELATED FACTORS**

```{r mx set up}
# mxOption(NULL, "Default optimizer","CSOLNP") #what does this actually do???? 
```

```{r number of variables (phenotypes)}
nv	<- 4			# number of variables for a twin 
ntv	<- 2*nv		# number of variables for a pair 
```

## Saturated model

#### Parameter labels

First we need to specify the start values and labels to make the code less busy. 
For the start values, I used the describe tables above to look for the approximate value the model should be looking for. 
The list should reflect the same order that you have in selvars. 

*Labels for variables*
The correlations should reflect all in the matrix that are not 1 and below/above the diagonal, an example of the labelling is below:

Fruhling's labeling:
        sisoe5   sisoe7   sisoy5  sisoy7
sisoe5  1.000      
sisoe7  rPhMZ1   1.000    
sisoy5  rMZ1     MZxtxt2  1.000  
sisoy7  MZxtxt1  rMZ2     rPhMZ2  1.000

My labeling:
        sisoe5  sisoe7  sisoy5 sisoy7
sisoe5  1.000      
sisoe7  xph1    1.000    
sisoy5  xt1     xtxph2  1.000  
sisoy7  xtxph1  xt2     xph2   1.000

**For the full correlation matrix:** 
         sisoe5   sisoe7   sisoe10  sisoe12  sisoy5  sisoy7  sisoy10  sisoy12
sisoe5   1.000   
sisoe7   xph1    1.000   
sisoe10  xph2    xph4     1.000   
sisoe12  xph3    xph5     xph6     1.000 
sisoy5   xt1     xtxph4   xtxph7   xtxph10  1.000  
sisoy7   xtxph1  xt2      xtxph8   xtxph11  xph7   1.000   
sisoy10  xtxph2  xtxph5   xt3      xtxph12  xph8   xph10   1.000  
sisoy12  xtxph3  xtxph6   xtxph9   xt4      xph9   xph11   xph12   1.000

      xph   = cross phenotype/variable/trait
      xt    = cross twin
      xtxph = cross twin cross phenotype


```{r specify saturated model}
# start values
svM	  <- c(0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7)	  # means               
svSD  <- c(1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1)    # standard deviations
svRmz <- c(rep(0.3, 28))                    # correlations for MZ - 28 correlations in total
svRdz <- c(rep(0.15, 28))                   # correlations for DZ 

# labels
labMZm	<- c("MZme5", "MZme7", "MZme10", "MZme12", "MZmy5", "MZmy7", "MZmy10", "MZmy12")	         # MZ means       
labDZm	<- c("DZme5", "DZme7", "DZme10", "DZme12", "DZmy5", "DZmy7", "DZmy10", "DZmy12")           # DZ means

labMZsd	<- c("MZsde5", "MZsde7", "MZsde10", "MZsde12", "MZsdy5", "MZsdy7", "MZsdy10", "MZsdy12")   # MZ standard deviations
labDZsd	<- c("DZsde5", "DZsde7", "DZsde10", "DZsde12", "DZsdy5", "DZsdy7", "DZsdy10", "DZsdy12")   # DZ standard deviations

labMZr	<- c("MZrxph1", "MZrxph2", "MZrxph3", "MZrxt1",	"MZrxtxph1", "MZrxtxph2", "MZrxtxph3",     # MZ correlations
            "MZrxph4", "MZrxph5", "MZrxtxph4", "MZrxt2", "MZrxtxph5", "MZrxtxph6", 
            "MZrxph6", "MZrxtxph7", "MZrxtxph8", "MZrxt3", "MZrxtxph9",
            "MZrxtxph10", "MZrxtxph11", "MZrxtxph12", "MZrxt4",
            "MZrxph7", "MZrxph8", "MZrxph9", 
            "MZrxph10", "MZrxph11",
            "MZrxph12")     
labDZr	<- c("DZrxph1", "DZrxph2", "DZrxph3", "DZrxt1",	"DZrxtxph1", "DZrxtxph2", "DZrxtxph3",     # DZ correlations
            "DZrxph4", "DZrxph5", "DZrxtxph4", "DZrxt2", "DZrxtxph5", "DZrxtxph6", 
            "DZrxph6", "DZrxtxph7", "DZrxtxph8", "DZrxt3", "DZrxtxph9",
            "DZrxtxph10", "DZrxtxph11", "DZrxtxph12", "DZrxt4",
            "DZrxph7", "DZrxph8", "DZrxph9", 
            "DZrxph10", "DZrxph11",
            "DZrxph12") 
```

#### Matrices

```{r matrices for saturated free parameters (means, sd, cor)}
# MZ
meanMZ	<- mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM,	labels = labMZm, name = "ExpMeanMZ")
sdMZ		<- mxMatrix(type = "Diag", nrow = ntv, ncol = ntv, free = TRUE, values = svSD,	labels = labMZsd, name = "sdMZ")
corMZ		<- mxMatrix(type = "Stand", nrow = ntv, ncol = ntv, free = TRUE, values = svRmz, labels = labMZr,	name = "corMZ") 

# DZ
meanDZ	<- mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM,	labels = labDZm, name = "ExpMeanDZ")
sdDZ		<- mxMatrix(type = "Diag", nrow = ntv, ncol = ntv, free = TRUE, values = svSD,	labels = labDZsd, name = "sdDZ")
corDZ		<- mxMatrix(type = "Stand", nrow = ntv, ncol = ntv, free = TRUE, values = svRdz, labels = labDZr,	name = "corDZ") 
```

#### Alegbra 

This is the same matrix algebra that is calculated above from the Boulder workshop code:

            covariace = SD * r * t(SD) 

%*% is matrix multiplication
t() is transpose
full list of operators [here](https://openmx.ssri.psu.edu/wiki/matrix-operators-and-functions) 

The result matrix of the matrix algebra calculation S*R*S’ is the Symmetric Variance-Covariance matrix of the model, with the expected Variance of the Twin 1 variable on the 1st Diagonal Element, the expected Variance of the Twin 2 variable on the 2nd  Diagonal Element and the Covariance on the off-diagonal. Since we are dealing with two types of Twin pairs, we will specify a different S and R matrix for MZ and DZ pairs and fit a separate Saturated model to each of the sub-data files, the MZ data and the DZ data. 

```{r Algebra for saturated expected variance/covariance matrices for MZ and DZ pairs}
covMZ	<- mxAlgebra(expression = sdMZ %*% corMZ %*% t(sdMZ), name = "ExpCovMZ")
covDZ	<- mxAlgebra(expression = sdDZ %*% corDZ %*% t(sdDZ), name = "ExpCovDZ")
```

#### Data 

We need to specify what data to populate the matrices with.

```{r specify saturated data objects to be saved in openMx format}
datMZ <- mxData(observed = dat.twin.MZ, type = "raw")
datDZ <- mxData(observed = dat.twin.DZ, type = "raw")
```

#### Objectives 

*I'm not sure what objectives are - why do we need them?*

```{r create saturated objectives}
# Objective objects 
objMZ <- mxExpectationNormal(covariance = "ExpCovMZ", means = "ExpMeanMZ", dimnames = selvars)
objDZ <- mxExpectationNormal(covariance = "ExpCovDZ", means = "ExpMeanDZ", dimnames = selvars)
```

#### Specify fit function

```{r fit function for saturated model}
fitFunction <- mxFitFunctionML()
```

#### Create the model

*the confidence intervals here definitely need editing but I don't know how - maybe look at Tims scripts for this*. I have hashed out the confidence interval specification for now as I'm not sure how to update this. 

```{r create saturated model}
# models for MZ and DZ
modelMZ	<- mxModel(meanMZ, sdMZ, corMZ, covMZ, datMZ, objMZ, fitFunction, name = "MZ")
modelDZ	<- mxModel(meanDZ, sdDZ, corDZ, covDZ, datDZ, objDZ, fitFunction, name = "DZ")

# estimation
minus2ll <- mxAlgebra(expression = MZ.objective + DZ.objective, name = "m2LL")
obj	<- mxFitFunctionAlgebra("m2LL")

# confidence intervals
# Conf1 <- mxCI(c('MZ.MZCor[2,1]', 'MZ.MZCor[3,1]', 'MZ.MZCor[4,1]', 'MZ.MZCor[4,2]')) # edit these???????????
# Conf2 <- mxCI(c('DZ.DZCor[3,1]', 'DZ.DZCor[4,1]', 'DZ.DZCor[4,2]'))

# Saturated model 
SatModel <- mxModel("Sat", modelMZ, modelDZ, minus2ll, obj 
                    #Conf1, Conf2
                    )
```

#### Saturated model output

The Saturated Model is represented by a path diagram and using path tracing rules we will derive the expected model for the variance-covariance structure of the data. The ultimate goal of the Saturated Model is to obtain the best possible (maximum likelihood) estimation of the ‘Twin Correlations’ and this is preferred over the correlations that you can typically get using R commands (also shown above). 

*** 
THINK ABOUT THIS
Estimating ACE based on the saturated model as an example:
Falconer’s equations	a2 = 2*(rMZ-rDZ); c2= rMZ-a2; e2=1-a2-c2
Social isolation at age 5 -> a2 = 2*
rMZ = 
***

```{r saturated model output}
# Run the saturated model
SatFit	<- mxRun(SatModel, intervals = FALSE)
(SatSumm	<- summary(SatFit))

# Generate SatModel Output so you could see the labels
SatFit$MZ.corMZ
SatFit$MZ.ExpCovMZ
SatFit$DZ.corDZ
SatFit$DZ.ExpCovDZ
```

Although the ultimate goal is to decompose the variance into components A, C and E, we first start with the Saturated Model. This Model simply estimates the variances of the variables in MZ and DZ twin pairs, as well as the covariance in each group. The model therefore provides a basis to *test certain assumptions* that are implicit in the ACE model, and that is: that **all variances should be alike or more precisely, non-significantly different**. This means that we don’t expect birth order nor zygosity effects on the variances so that  Var1=Var2=Var3=Var4. The correlations estimated by optimizing the Saturated Model using OpenMx, will also have the benefit that they will be corrected for missingness in the data and therefore representing the best possible estimates. The third reason for the Saturated Model is to obtain a baseline fit index (-2 * the likelihood, -2LL) for the observed data, to be used as a reference for comparison with the likelihood (-2LL) of the genetic models. 

### Specify saturated sub-model 1: Constrained correlation model (equal variances & means across twin order & zygosity group)

To manipulate  the parameters in matrices we wish to change in the full model, we use the 'omxSetParameters' function with the original 'labels' and 'newlabels' to indicate the changes, i.e. specifying the same label effectively constraints the parameters to be the same. 

Here we have equated means and variances across twin order and zygosity. Then created *one overall set of within-person cross-trait correlations and symmetric xtwin-xtrait correlation matrices in MZ and DZ groups*.  

Labeling:
        sisoe5  sisoe7  sisoy5 sisoy7
sisoe5  1.000      
sisoe7  xph     1.000    
sisoy5  xt1     xtxph   1.000  
sisoy7  xtxph   xt2     xph    1.000

**For the full matrix:** 
         sisoe5   sisoe7   sisoe10  sisoe12     sisoy5  sisoy7  sisoy10  sisoy12
sisoe5   1.000   
sisoe7   xph1    1.000   
sisoe10  xph2    xph4     1.000   
sisoe12  xph3    xph5     xph6     1.000 

sisoy5   xt1     xtxph1   xtxph2   xtxph3       1.000  
sisoy7   xtxph1  xt2      xtxph4   xtxph5       xph1   1.000   
sisoy10  xtxph2  xtxph4   xt3      xtxph6       xph2   xph4   1.000  
sisoy12  xtxph3  xtxph5   xtxph6   xt4          xph3   xph5   xph6   1.000

```{r specify saturday submodel 1 new labels}
# start values
newsvRmz <- c(rep(0.3, 16))                    # correlations for MZ - 16 distinct correlations in total
newsvRdz <- c(rep(0.15, 16))                   # correlations for DZ 

# labels
newlabm	<- c("m5", "m7", "m10", "m12", "m5", "m7", "m10", "m12")	         # means       
newlabsd	<- c("sd5", "sd7", "sd10", "sd12", "sd5", "sd7", "sd10", "sd12") # standard deviations

newlabrMZ	<- c("rxph1", "rxph2", "rxph3", "MZrxt1",	"MZrxtxph1", "MZrxtxph2", "MZrxtxph3",     # MZ correlations
            "rxph4", "rxph5", "MZrxtxph1", "MZrxt2", "MZrxtxph4", "MZrxtxph5", 
            "rxph6", "MZrxtxph2", "MZrxtxph4", "MZrxt3", "MZrxtxph6",
            "MZrxtxph3", "MZrxtxph5", "MZrxtxph6", "MZrxt4",
            "rxph1", "rxph2", "rxph3", 
            "rxph4", "rxph5",
            "rxph6")  
newlabrDZ	<- c("rxph1", "rxph2", "rxph3", "DZrxt1",	"DZrxtxph1", "DZrxtxph2", "DZrxtxph3",     # DZ correlations
            "rxph4", "rxph5", "DZrxtxph1", "DZrxt2", "DZrxtxph4", "DZrxtxph5", 
            "rxph6", "DZrxtxph2", "DZrxtxph4", "DZrxt3", "DZrxtxph6",
            "DZrxtxph3", "DZrxtxph5", "DZrxtxph6", "DZrxt4",
            "rxph1", "rxph2", "rxph3", 
            "rxph4", "rxph5",
            "rxph6") 
```

```{r specify saturated submodel 1}
# create model 
Sub1Model	<- mxModel(SatModel, name = "Sub1")

# set parameters to be the same across 
# equal means
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svM, labels = labMZm, newlabels = newlabm)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svM, labels = labDZm, newlabels = newlabm)
# equal variances
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svSD, labels = labMZsd, newlabels = newlabsd)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svSD, labels = labDZsd, newlabels = newlabsd)
# equal correlations
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = newsvRmz, labels = labMZr, newlabels = newlabrMZ)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = newsvRdz, labels = labDZr, newlabels = newlabrDZ)

# for some reason it's the wrong number of starting values so to choose randomly I've set the below
Sub1Model <- omxAssignFirstParameters(Sub1Model)
```

```{r run saturated sub model 1}
Sub1Fit	<- mxRun(Sub1Model, intervals = TRUE)
(Sub1Summ	<- summary(Sub1Fit))
```

As the p-value is significant, the sub-model is significantly worse fit compared to the saturated model - **what do I do with this?** 

```{r submodel 1 output}
Sub1Fit$MZ.ExpCovMZ
Sub1Fit$MZ.MZCor
Sub1Fit$DZ.ExpCovDZ
Sub1Fit$DZ.DZCor

mxCompare(SatFit, Sub1Fit)
```

## ACE model

#### Matrices to estimate a, c, and e path coefficients

```{r ace matrices}
pathA	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(1,-4,8), labels = c("a11", "a21","a22"), name="a" ) 
pathC	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(1,-4,8), labels = c("c11", "c21","c22"), name="c" )
pathE	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(1,-4,8), labels = c("e11", "e21","e22"), name="e" )
```



























