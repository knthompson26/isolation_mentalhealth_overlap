---
title: "Behavioural genetics analysis of social isolation: Cholesky decomposition"
output:  
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: false
    number_sections: false
    highlight: monochrome
    theme: flatly
    code_folding: show
    includes:
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      prompt = FALSE,
                      cache = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      results = 'markup')

options(bitmapType = 'quartz') # to render fonts better
```

```{r Clear global environment, include=FALSE}
remove(list = ls())
```

```{r Load packages, include=FALSE}
library(knitr)
library(haven)
library(psych)   
library(OpenMx)
library(tidyr)
library(tidyverse)
library(dplyr) #conflicts with tidyverse for e.g. rename and row_number
```

```{r source the data file path, include=FALSE}
# source raw data directory
source("../isolation_mentalhealth_data_path.R")
```

```{r read in dta data file, include=FALSE}
dat.raw <- read_dta(paste0(data_path_raw, "Katie_23Sep22.dta"))
colnames(dat.raw)
```

# Data prep

### Column names

```{r select variables needed}
dat <- dat.raw %>%
  dplyr::select(
         atwinid,
         btwinid,
         familyid,
         rorderp5,
         torder,
         zygosity,
         sampsex,
         seswq35,
         sethnic,
         sisoe5,
         sisoe7,
         sisoe10,
         sisoe12,
         sisoy5,
         sisoy7,
         sisoy10,
         sisoy12
  )

colnames(dat)
```

### Recode variables into factors {.tabset .tabset-fade}

#### Sex

```{r recode sex}
dat <- dat %>%
  mutate(
    sex = 
      recode_factor(as_factor(sampsex),
        "1" = "Male",
        "2" = "Female"))

table(dat$sex)
```

#### SES

```{r recode SES}
dat <- dat %>%
  mutate(
    ses = 
      recode_factor(as_factor(seswq35),
        "1" = "Low",
        "2" = "Middle", 
        "3" = "High"))

table(dat$ses)
```

#### Zygosity

```{r recode zygosity}
dat <- dat %>%
  mutate(
    zygosity = 
      recode_factor(as_factor(zygosity),
        "1" = "MZ",
        "2" = "DZ"))

table(dat$zygosity)
```

#### Ethnicity

```{r recode ethnicity variable}
dat <- dat %>%
  mutate(
    ethnicity = 
      recode_factor(as_factor(sethnic),
        "1" = "White",
        "2" = "Asian", 
        "3" = "Black",
        "4" = "Mixed race",
        "5" = "Other"))

table(dat$ethnicity)
```

### Convert variables to numeric

```{r create numeric isolation variables}
dat <- dat %>%
  mutate(
    sisoe5 = as.numeric(sisoe5),      # isolation elder
    sisoe7 = as.numeric(sisoe7),
    sisoe10 = as.numeric(sisoe10),
    sisoe12 = as.numeric(sisoe12),
    sisoy5 = as.numeric(sisoy5),      # isolation younger
    sisoy7 = as.numeric(sisoy7),
    sisoy10 = as.numeric(sisoy10),
    sisoy12 = as.numeric(sisoy12)
  )
```

### Create twin dataset

```{r remove variables not needed}
dat <- dat %>% select(
      -c(sampsex, 
         seswq35)
         )
```

To remove the double entry in the data, we will remove everyone who has a "random twin order" variable of 0. This will then remove any birth order effects. 

```{r remove one twin pair row}
dat.twin <- dat %>% filter(rorderp5 == "1")
```

```{r datasets for MZ and DZ}
# with all data to check numbers
dat.MZ <- dat %>% filter(zygosity == "MZ")
dat.DZ <- dat %>% filter (zygosity == "DZ")

# twin layout
dat.twin.MZ <- dat.twin %>% filter(zygosity == "MZ")
dat.twin.DZ <- dat.twin %>% filter (zygosity == "DZ")
```

### Summary of MZ and DZ data

```{r describe MZ and DZ data}
MZ_summary <- describe(dat.twin.MZ, 
                       skew = FALSE, 
                       range = FALSE)
MZ_summary

DZ_summary <- describe(dat.twin.DZ, 
                       skew = FALSE, 
                       range = FALSE)
DZ_summary
```

# Correlation matrices

```{r select variables for correlations}
selvars <- c("sisoe5", "sisoe7", "sisoe10", "sisoe12", "sisoy5", "sisoy7", "sisoy10", "sisoy12")
```

The rule of thumb for choosing an ACE or ADE model is: 

 - if 2*rdz>rmz, choose an ACE model; 
 - if 2*rdz<rmz, choose a ADE model

```{r MZ matrices}
# covariance matrix
covar.mz <- cov(dat.twin.MZ[, selvars], use = "complete")

# correlation matrix (standardized covariance)
cor.mz <- cor(dat.twin.MZ[, selvars], use = "complete")
round(cor.mz, 3)
```

```{r DZ matrices}
# covariance matrix
covar.dz <- cov(dat.twin.DZ[, selvars], use = "complete")

# correlation matrix (standardized covariance)
cor.dz <- cor(dat.twin.DZ[, selvars], use = "complete")
round(cor.dz, 3)
```

ADE vs ACE estimation:

|                         | rMZ   | rDZ   | 2*rDZ | Model |
|------------------------ | ----- | ----- | ----- | ----- |
| Social isolation age 5  | 0.585 | 0.056 | 0.112 | ADE   | 
| Social isolation age 7  | 0.444 | 0.159 | 0.318 | ADE   | 
| Social isolation age 10 | 0.453 | 0.174 | 0.348 | ADE   | 
| Social isolation age 12 | 0.453 | 0.110 | 0.220 | ADE   | 


A high dominance effect would not make sense for a social behaviour. It's more likely that **as the MZ correlations are relatively low, an AE would be the suggested model - so that A captures all additive and dominant genetic effects.** The rDZ for age five seems *particularly* low here. 

Falconer's equations:
W can obtain preliminary estimates of the standardized A, C, E variance components. 

VA = 2*rmz-rdz
VC = 1-VA+VE
VE= 1-rmz

For age 5: 

VA = 2*0.59-0.056 = 1.068
VC = 1- 1.068 + 0.41 = -0.4789
VE = 1 - 0.59 = 0.41

As C is negative here, it's likely that the OpenMX model will give a very small estimate for C and that C will be dropped from the ACE model. The power to detect C is very low, to detect a C2 of 10% with a h2 of 60% requires 2200 MZ and DZ pairs. However, when deciding on an AE model, any C that does exist will fall into A and you will get an inflated heritability estimate. 

***

Below is not needed for the analyses - but showing another way to compute matrices in R. 

```{r express covariance matrix using SD and correlations}
# variances from covariance matrix - diagonal is one variable with itself
var.mz <- diag(covar.mz) 

# creating the standard deviation into a vector (sd is the square root of the variance) then put this into a matrix
sd.mz <- diag(sqrt(var.mz))

# re-calculating variance of MZ 
Smz <- sd.mz%*%cor.mz%*%t(sd.mz) 
round(covar.mz - Smz, 3) # compare with previous calculation

# Therefore, we can also obtain the correlation matrix as follows
rMZ <- cov2cor(covar.mz)
```

***

# Saturated model

## Parameter labels

Notation for the labeling:

      xph   = cross phenotype/variable/trait
      xt    = cross twin
      xtxph = cross twin cross phenotype

Full correlation matrix:
  
   4x4       | sisoe5  | sisoe7   | sisoe10  | sisoe12  | sisoy5 | sisoy7  | sisoy10  | sisoy12 |
------------ | ------- | -------- | -------- | -------- | ------ | ------- | -------- | ------  |        
**sisoe5**   | 1.000   |          |          |          |        |         |          |         | 
**sisoe7**   | xph1    | 1.000    |          |          |        |         |          |         |
**sisoe10**  | xph2    | xph4     | 1.000    |          |        |         |          |         |    
**sisoe12**  | xph3    | xph5     | xph6     | 1.000    |        |         |          |         |            
**sisoy5**   | xt1     | xtxph4   | xtxph7   | xtxph10  | 1.000  |         |          |         |                             
**sisoy7**   | xtxph1  | xt2      | xtxph8   | xtxph11  | xph7   | 1.000   |          |         |                     
**sisoy10**  | xtxph2  | xtxph5   | xt3      | xtxph12  | xph8   | xph10   | 1.000    |         |                        
**sisoy12**  | xtxph3  | xtxph6   | xtxph9   | xt4      | xph9   | xph11   | xph12    | 1.000   |


We first specify the start values and labels to make the code less busy. For the start values, I used the summary tables to check the approximate value the model should be looking for. The list should reflect the same order as in `selvars`. 

```{r number of variables (phenotypes)}
nv	<- 4			# number of variables for a twin 
ntv	<- 2*nv		# number of variables for a pair 
```

```{r specify saturated model}
# start values
svM	  <- c(0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7)	  # means               
svSD  <- c(1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1, 1.1)    # standard deviations
svRmz <- c(rep(0.3, 28))                              # correlations for MZ - 28 correlations in total
svRdz <- c(rep(0.15, 28))                             # correlations for DZ 

# labels
labMZm	<- c("MZme5", "MZme7", "MZme10", "MZme12", "MZmy5", "MZmy7", "MZmy10", "MZmy12")	         # MZ means       
labDZm	<- c("DZme5", "DZme7", "DZme10", "DZme12", "DZmy5", "DZmy7", "DZmy10", "DZmy12")           # DZ means

labMZsd	<- c("MZsde5", "MZsde7", "MZsde10", "MZsde12", "MZsdy5", "MZsdy7", "MZsdy10", "MZsdy12")   # MZ standard deviations
labDZsd	<- c("DZsde5", "DZsde7", "DZsde10", "DZsde12", "DZsdy5", "DZsdy7", "DZsdy10", "DZsdy12")   # DZ standard deviations

labMZr	<- c("MZrxph1", "MZrxph2", "MZrxph3", "MZrxt1",	"MZrxtxph1", "MZrxtxph2", "MZrxtxph3",     # MZ correlations
            "MZrxph4", "MZrxph5", "MZrxtxph4", "MZrxt2", "MZrxtxph5", "MZrxtxph6", 
            "MZrxph6", "MZrxtxph7", "MZrxtxph8", "MZrxt3", "MZrxtxph9",
            "MZrxtxph10", "MZrxtxph11", "MZrxtxph12", "MZrxt4",
            "MZrxph7", "MZrxph8", "MZrxph9", 
            "MZrxph10", "MZrxph11",
            "MZrxph12")     
labDZr	<- c("DZrxph1", "DZrxph2", "DZrxph3", "DZrxt1",	"DZrxtxph1", "DZrxtxph2", "DZrxtxph3",     # DZ correlations
            "DZrxph4", "DZrxph5", "DZrxtxph4", "DZrxt2", "DZrxtxph5", "DZrxtxph6", 
            "DZrxph6", "DZrxtxph7", "DZrxtxph8", "DZrxt3", "DZrxtxph9",
            "DZrxtxph10", "DZrxtxph11", "DZrxtxph12", "DZrxt4",
            "DZrxph7", "DZrxph8", "DZrxph9", 
            "DZrxph10", "DZrxph11",
            "DZrxph12") 
```

## Matrices

```{r matrices for saturated free parameters (means, sd, cor)}
# MZ
meanMZ	<- mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM,	labels = labMZm, name = "ExpMeanMZ")
sdMZ		<- mxMatrix(type = "Diag", nrow = ntv, ncol = ntv, free = TRUE, values = svSD,	labels = labMZsd, name = "sdMZ")
corMZ		<- mxMatrix(type = "Stand", nrow = ntv, ncol = ntv, free = TRUE, values = svRmz, labels = labMZr,	name = "corMZ") 

# DZ
meanDZ	<- mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM,	labels = labDZm, name = "ExpMeanDZ")
sdDZ		<- mxMatrix(type = "Diag", nrow = ntv, ncol = ntv, free = TRUE, values = svSD,	labels = labDZsd, name = "sdDZ")
corDZ		<- mxMatrix(type = "Stand", nrow = ntv, ncol = ntv, free = TRUE, values = svRdz, labels = labDZr,	name = "corDZ") 
```

## Alegbra 

Matrix algebra to calculate covariance:

            covariace = SD * r * t(SD) 

* %*% is matrix multiplication
* t() is transpose
* full list of operators [here](https://openmx.ssri.psu.edu/wiki/matrix-operators-and-functions) 

The result matrix of the algebra calculation S*R*S’ is the symmetric variance-covariance matrix of the model, with the expected variances on the diagonal and covariance on the off-diagonal. Since we are dealing with two types of Twin pairs, we will specify a different S and R matrix for MZ and DZ pairs and fit a separate Saturated model to each of the sub-data files, the MZ data and the DZ data. 

```{r Algebra for saturated expected variance/covariance matrices for MZ and DZ pairs}
covMZ	<- mxAlgebra(expression = sdMZ %*% corMZ %*% t(sdMZ), name = "ExpCovMZ")
covDZ	<- mxAlgebra(expression = sdDZ %*% corDZ %*% t(sdDZ), name = "ExpCovDZ")
```

```{r specify saturated data objects to be saved in openMx format}
datMZ <- mxData(observed = dat.twin.MZ, type = "raw")
datDZ <- mxData(observed = dat.twin.DZ, type = "raw")
```

```{r create saturated objectives}
objMZ <- mxExpectationNormal(covariance = "ExpCovMZ", means = "ExpMeanMZ", dimnames = selvars)
objDZ <- mxExpectationNormal(covariance = "ExpCovDZ", means = "ExpMeanDZ", dimnames = selvars)
```

```{r fit function for all models}
fitFunction <- mxFitFunctionML()
```

### Estimation

```{r create saturated model}
# models for MZ and DZ
modelMZ	<- mxModel(meanMZ, sdMZ, corMZ, covMZ, datMZ, objMZ, fitFunction, name = "MZ")
modelDZ	<- mxModel(meanDZ, sdDZ, corDZ, covDZ, datDZ, objDZ, fitFunction, name = "DZ")

# estimation
minus2ll <- mxAlgebra(expression = MZ.objective + DZ.objective, name = "m2LL")
obj	<- mxFitFunctionAlgebra("m2LL")

# Saturated model 
SatModel <- mxModel("Sat", modelMZ, modelDZ, minus2ll, obj)
```

## Output {.tabset .tabset-fade}

The goal of the saturated model is to obtain the best possible (maximum likelihood) estimation of the twin correlations and this is preferred over the correlations that you can typically get using R commands (also shown above). 

The cross-twin correlations (rxt) are expected to be different, and the cross-twin cross-trait (rxtxph) are expected to be different. However, the within-twin cross trait (rxph) are not supposed to differ for the elder and younger twins.

### Overall summary

```{r saturated model output summary}
# Run the saturated model
SatFit	<- mxRun(SatModel, intervals = FALSE)
(SatSumm	<- summary(SatFit))
```

### MZ 

```{r saturated model output MZ}
SatFit$MZ.corMZ     # correlations
SatFit$MZ.ExpCovMZ  # covariance
```

### DZ 

```{r saturated model output DZ}
SatFit$DZ.corDZ     # correlations
SatFit$DZ.ExpCovDZ  # covariance
```

# Saturated sub-models {.tabset .tabset-fade}

Saturated sub-models can test assumptions that are implicit in the ACE model:

- Variances should be non-significantly different across twin order and zygosity
- Means hsould be non-significantly different across twin order and zygosity
- Thus, Var1 = Var2 = Var3 = Var4 and Mean1 = Mean2 = Mean3 = Mean4

We can change parameters in the model using the 'omxSetParameters' function with the original 'labels' and 'newlabels' to indicate the changes. The correlations estimated by the saturated Model correct for missingness. The saturated model also gives a baseline fit index (-2 * the likelihood, -2LL) for the observed data, to be used as a reference for comparison with the likelihood (-2LL) of the genetic models. 

## Saturated sub-model 1

**Constraining everything at once. Equal means and variances across twin order and zygosity with one set of cross-phenotype correlations and symmetric xtwin-xpheno correlations** 

We have equated means and variances across twin order and zygosity. Then created one overall set of within-person cross-trait correlations and symmetric xtwin-xtrait correlation matrices in MZ and DZ groups. 

Labeling for the full matrix that has been constrained:

  4x4        | sisoe5  | sisoe7   | sisoe10  | sisoe12 |    |sisoy5 | sisoy7  | sisoy10  | sisoy12 |
------------ | ------- | -------- | -------- | ------- | -- | ----- | ------- | -------- | ------- |         
**sisoe5**   | 1.000   |          |          |         |    |       |         |          |         |            
**sisoe7**   | xph1    | 1.000    |          |         |    |       |         |          |         |             
**sisoe10**  | xph2    | xph4     | 1.000    |         |    |       |         |          |         |                 
**sisoe12**  | xph3    | xph5     | xph6     | 1.000   |    |       |         |          |         |              
             |         |          |          |         |    |       |         |          |         |       
**sisoy5**   | xt1     | xtxph1   | xtxph2   | xtxph3  |    | 1.000 |         |          |         |    
**sisoy7**   | xtxph1  | xt2      | xtxph4   | xtxph5  |    | xph1  | 1.000   |          |         |            
**sisoy10**  | xtxph2  | xtxph4   | xt3      | xtxph6  |    | xph2  | xph4    | 1.000    |         |              
**sisoy12**  | xtxph3  | xtxph5   | xtxph6   | xt4     |    | xph3  | xph5    | xph6     | 1.000   |                   

```{r specify saturday submodel 1 new labels}
# start values
sub1svRmz <- c(rep(0.3, 16))                    # correlations for MZ - 16 distinct correlations in total
sub1svRdz <- c(rep(0.15, 16))                   # correlations for DZ 

# labels
sub1labm	<- c("m5", "m7", "m10", "m12", "m5", "m7", "m10", "m12")	         # means       
sub1labsd	<- c("sd5", "sd7", "sd10", "sd12", "sd5", "sd7", "sd10", "sd12") # standard deviations

sub1labrMZ	<- c("rxph1", "rxph2", "rxph3", "MZrxt1",	"MZrxtxph1", "MZrxtxph2", "MZrxtxph3",     # MZ correlations
            "rxph4", "rxph5", "MZrxtxph1", "MZrxt2", "MZrxtxph4", "MZrxtxph5", 
            "rxph6", "MZrxtxph2", "MZrxtxph4", "MZrxt3", "MZrxtxph6",
            "MZrxtxph3", "MZrxtxph5", "MZrxtxph6", "MZrxt4",
            "rxph1", "rxph2", "rxph3", 
            "rxph4", "rxph5",
            "rxph6")  
sub1labrDZ	<- c("rxph1", "rxph2", "rxph3", "DZrxt1",	"DZrxtxph1", "DZrxtxph2", "DZrxtxph3",     # DZ correlations
            "rxph4", "rxph5", "DZrxtxph1", "DZrxt2", "DZrxtxph4", "DZrxtxph5", 
            "rxph6", "DZrxtxph2", "DZrxtxph4", "DZrxt3", "DZrxtxph6",
            "DZrxtxph3", "DZrxtxph5", "DZrxtxph6", "DZrxt4",
            "rxph1", "rxph2", "rxph3", 
            "rxph4", "rxph5",
            "rxph6") 
```

```{r specify saturated submodel 1}
# create model 
Sub1Model	<- mxModel(SatModel, name = "Sub1")

# equal means
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svM, labels = labMZm, newlabels = sub1labm)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svM, labels = labDZm, newlabels = sub1labm)
# equal variances
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svSD, labels = labMZsd, newlabels = sub1labsd)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = svSD, labels = labDZsd, newlabels = sub1labsd)
# equal correlations
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = sub1svRmz, labels = labMZr, newlabels = sub1labrMZ)
Sub1Model	<- omxSetParameters(Sub1Model, free = TRUE, values = sub1svRdz, labels = labDZr, newlabels = sub1labrDZ)

# for some reason it's the wrong number of starting values so to choose randomly I've set the below
Sub1Model <- omxAssignFirstParameters(Sub1Model)
```

```{r run saturated sub model 1}
Sub1Fit	<- mxRun(Sub1Model, intervals = TRUE)
(Sub1Summ	<- summary(Sub1Fit))
```

```{r submodel 1 output}
# Sub1Fit$MZ.ExpCovMZ
# Sub1Fit$MZ.MZCor
# Sub1Fit$DZ.ExpCovDZ
# Sub1Fit$DZ.DZCor

# compare the fit to the saturated model
mxCompare(SatFit, Sub1Fit)
```

As the p-value is significant, the sub-model is significantly worse fit compared to the saturated model. Now we will constrain different aspects here to see where the inequality in variance is coming up. 

## Saturated sub-model 2

**Equal variances/sd across twin order**

```{r specify submodel 2 new labels - only changing sd values to be equal across elder and younger twins}
sub2labMZsd	<- c("MZsd5", "MZsd7", "MZsd10", "MZsd12", "MZsd5", "MZsd7", "MZsd10", "MZsd12")   # MZ standard deviations
sub2labDZsd	<- c("DZsd5", "DZsd7", "DZsd10", "DZsd12", "DZsd5", "DZsd7", "DZsd10", "DZsd12")   # DZ standard deviations
```

```{r sub model 2 - equal variances across twin order}
Sub2Model <- mxModel(SatModel, name = "Sub2")
Sub2Model <- omxSetParameters(Sub2Model, free = TRUE, values = svSD, labels = labMZsd, newlabels = sub2labMZsd)
Sub2Model <- omxSetParameters(Sub2Model, free = TRUE, values = svSD, labels = labDZsd, newlabels = sub2labDZsd)

# fit model
Sub2Fit	<- mxRun(Sub2Model, intervals = TRUE)
(Sub2Summ	<- summary(Sub2Fit))

# compare to saturated
mxCompare(SatFit, Sub2Fit)
```

This is significant, suggesting that the variance is not equal across elder and younger twins within MZ and DZ groups separately. 

## Saturated sub-model 3 

**Equal variances/sd across zygosity**

We will run equal variances across zygosity only (as the twin order test was significant). 

```{r specify saturday submodel 3 new labels}
sub3labMZsd	<- c("sde5", "sde7", "sde10", "sde12", "sdy5", "sdy7", "sdy10", "sdy12")   # MZ standard deviations
sub3labDZsd	<- c("sde5", "sde7", "sde10", "sde12", "sdy5", "sdy7", "sdy10", "sdy12")   # DZ standard deviations
```

```{r sub model 3 - equal variances zygosity}
sub3Model <- mxModel(SatModel, name = "sub3")
sub3Model <- omxSetParameters(sub3Model, free = TRUE, values = svSD, labels = labMZsd, newlabels = sub3labMZsd)
sub3Model <- omxSetParameters(sub3Model, free = TRUE, values = svSD, labels = labDZsd, newlabels = sub3labDZsd)

# fit model
sub3Fit	<- mxRun(sub3Model, intervals = TRUE)
(sub3Summ	<- summary(sub3Fit))

# compare to saturated
mxCompare(SatFit, sub3Fit)
```

This is also significant, suggesting that the variance is not equal across MZ and DZ groups, even when not restricting to twin-order. 

## Saturated sub-model 4 

**Equal means across twin order**

```{r specify saturday submodel 4 new labels}
sub4labMZm	<- c("MZm5", "MZm7", "MZm10", "MZm12", "MZm5", "MZm7", "MZm10", "MZm12")	  # MZ means       
sub4labDZm	<- c("DZm5", "DZm7", "DZm10", "DZm12", "DZm5", "DZm7", "DZm10", "DZm12")    # DZ means
```

```{r sub model 4 - equal means across twin order}
sub4Model <- mxModel(SatModel, name = "sub4")
sub4Model <- omxSetParameters(sub4Model, free = TRUE, values = svM, labels = labMZm, newlabels = sub4labMZm)
sub4Model <- omxSetParameters(sub4Model, free = TRUE, values = svM, labels = labDZm, newlabels = sub4labDZm)

# fit model
sub4Fit	<- mxRun(sub4Model, intervals = TRUE)
(sub4Summ	<- summary(sub4Fit))

# compare to saturated
mxCompare(SatFit, sub4Fit)
```

This p value would round to p = 0.05 so I would interpret this as not significant. This suggests there are equal means across twin order (elder and younger variables). 

## Saturated sub-model 5 

**Equal means across twin order and zygosity**

The labels for these have already been done in the sub1 model (which constrains everything at once). 

```{r sub model 5 - equal means across twin order and zygosity}
sub4Model <- mxModel(SatModel, name = "sub4")
sub4Model <- omxSetParameters(sub4Model, free = TRUE, values = svM, labels = labMZm, newlabels = sub1labm)
sub4Model <- omxSetParameters(sub4Model, free = TRUE, values = svM, labels = labDZm, newlabels = sub1labm)

# fit model
sub4Fit	<- mxRun(sub4Model, intervals = TRUE)
(sub4Summ	<- summary(sub4Fit))

# compare to saturated
mxCompare(SatFit, sub4Fit)
```

This is significant, which suggests that although the means are equal across twin order, they are not equal across twin order and zygosity.

***

# ACE model 

## Matrices

The structure of the Cholesky decomposition matrix, is one where the first latent A, C, and E factors (A1, C1 and E1) influence both variables, but the second factors (A2, C2 and E2) only influence the second variable. This is matrix type ‘Lower’. The factor loadings a11 and a21 and a22 follow a pattern where the matrix has the diagonal and lower elements, but the upper diagonal element is zero. 

Reminder: **Matrices are always (row, column)**.

Here we have 4 variables (social isolation at ages 5, 7, 10, 12), so this will be a 4x4 matrix: 

|                          | A1   | A2   | A3   | A4 |
| ------------------------ | ---- | ---- | ---- | -- |
| Isolation age 5 Twin 1   | a11  | 0    | 0    | 0  |   
| Isolation age 7 Twin 1   | a21  | a22  | 0    | 0  |   
| Isolation age 10 Twin 1  | a31  | a32  | a33  | 0  |
| Isolation age 12 Twin 1  | a41  | a42  | a43  | a44|

a11 = genetic influence on time point 1
a21 = genetic influence of time point 1 shared with time point 2
a22 = new genetic influence at time point 2


```{r ace matrices}
pathA	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(rep(0.5, 10)), 
                  labels = c("a11", "a21","a31","a41","a22","a32","a42","a33","a43","a44"), name = "a") 
pathC	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(rep(0.5, 10)), 
                  labels = c("c11", "c21","c31","c41","c22","c32","c42","c33","c43","c44"), name = "c")
pathE	<- mxMatrix(type = "Lower", nrow = nv, ncol = nv, free = TRUE, values = c(rep(0.5, 10)), 
                  labels = c("e11", "e21","e31","e41","e22","e32","e42","e33","e43","e44"), name = "e")
```

```{r matrix for the expected means}
MeanG	<-mxMatrix(type = "Full", nrow = 1, ncol = ntv, free = TRUE, values = svM, labels = sub1labm, name = "ExpMean")
```

## Algebra 

We compute the covariance matrix (V) which is the sum of the ACE variance components. Using row-by-col multiplication of a and a transpose, we get the 4x4 A variance covariance matrix of the four variables. We do this multiplication for c and e as well to get the C and E Var/Cov matrix. We can then standardise them to get h2, c2, and e2. 

```{r algebra to generate A, C, E variance components}
# Non-standardized variance components
covA	<- mxAlgebra(expression = a %*% t(a), name = "A")
covC	<- mxAlgebra(expression = c %*% t(c), name = "C") 
covE	<- mxAlgebra(expression = e %*% t(e), name = "E")

# Standardized variance components
covP <- mxAlgebra(expression = A + C + E, name = "V" )  # total variance in the phenotype
StA	<- mxAlgebra(expression = A/V, name = "h2")         # proportion of variance explained by additive genetic factors
StC	<- mxAlgebra(expression = C/V, name = "c2")         # proportion of variance explained by shared environment
StE	<- mxAlgebra(expression = E/V, name = "e2")         # proportion of variance explained by unique environment
```

### Factor correlations

We use the genetic Var/Cov matrix A to get the genetic correlation matrix with rA21 indicating the correlation between the A1 and A2 factors in the Bivariate model. 

```{r algebra to compute phenotypic ACE correlations}
matI <- mxMatrix(type = "Iden", nrow = nv, ncol = nv, name = "I")
matIsd <-mxAlgebra(solve(sqrt(I*V)), name = "isd") # extracting the variances from the diagonal of the covariance matrix V 
rph	<- mxAlgebra(expression = solve(sqrt(I*V)) %*% V %*% solve(sqrt(I*V)), name = "Rph") # new identity matrix for standardising 
rA	<- mxAlgebra(expression = solve(sqrt(I*A)) %*% A %*% solve(sqrt(I*A)), name = "Ra")
rC	<- mxAlgebra(expression = solve(sqrt(I*C)) %*% C %*% solve(sqrt(I*C)), name = "Rc") 
rE	<- mxAlgebra(expression = solve(sqrt(I*E)) %*% E %*% solve(sqrt(I*E)), name = "Re")
```

### Cholesky parameters

```{r cholesky parameters}
# path estimates
Sta <- mxAlgebra(isd%*%a, name = "sta")
Stc <- mxAlgebra(isd%*%c, name = "stc")
Ste <- mxAlgebra(isd%*%e, name = "ste")

# path estimates squared
Sta2 <- mxAlgebra(sta*sta, name = "sta2")
Stc2 <- mxAlgebra(stc*stc, name = "stc2")
Ste2 <- mxAlgebra(ste*ste, name = "ste2")
```

```{r algebra to put standardised parameter estimates into a matrix with col and row labels *}
rowVars	<- rep('Vars', nv)
colVars	<- rep(c('h2', 'c2', 'e2'), each = nv)
estVars	<- mxAlgebra(expression = cbind(h2,c2,e2), name = "Est", dimnames = list(rowVars,colVars))
```

### Proportional to phenotypic correlation 

If you want to work out the amount of the phenotypic correlation that is due to A, C or E, you can use the below: 

```{r algebra to compute Rph-A, Rph-C, and Rph-E between the two variables in a bivariate model (this would be different for more than two variables I guess)}
rphace <- mxAlgebra(expression = cbind((sqrt(h2[1,1])*Ra[2,1]*sqrt(h2[2,2])),
							(sqrt(c2[1,1])*Rc[2,1]*sqrt(c2[2,2])),
							(sqrt(e2[1,1])*Re[2,1]*sqrt(e2[2,2])) ), name = "RphACE" )
```

### Covariance estimation

The A factors are correlated across twins either by 1 for MZ pairs or 0.5 for DZ pairs, whereas the C factors are correlated 1 for either type of pairs. For the bivariate + model we have to correlate both the A1 and A2 factors across twins and both the C1 and C2 factors across twins.

```{r algebra for expected variance/covariance matrices in MZ and DZ twins}
covMZ	<- mxAlgebra(expression = rbind(cbind(A+C+E, A+C),
                                          cbind(A+C, A+C+E)), name = "expCovMZ" )
covDZ	<- mxAlgebra(expression = rbind(cbind(A+C+E, 0.5%x%A+C),
                                          cbind(0.5%x%A+C, A+C+E)), name = "expCovDZ" )
```

## Data

```{r data objects for ACE - this is repetition from earlier?}
# data objects 
dataMZ <- mxData(observed = dat.twin.MZ, type = "raw")
dataDZ <- mxData(observed = dat.twin.DZ, type = "raw")
```

```{r objective objects - is this is repetition from earlier?}
objMZ	<- mxExpectationNormal(covariance = "expCovMZ", means = "ExpMean", dimnames = selvars)
objDZ	<- mxExpectationNormal(covariance = "expCovDZ", means = "ExpMean", dimnames = selvars)
```

## Confidence intervals

```{r ACE confidence intervals}
# h2, c2, e2 
Conf1 <- mxCI(c('h2[1,1]', 'h2[2,2]','h2[3,3]', 'h2[4,4]', 'c2[1,1]', 'c2[2,2]', 'c2[3,3]', 'c2[4,4]', 'e2[1,1]', 'e2[2,2]', 'e2[3,3]', 'e2[4,4]')) # drop C if non-sig
# factor correlation - off-diagonal
Conf2	<- mxCI(c('Rph[2,1]', 'Ra[2,1]', 'Rc[2,1]', 'Re[2,1]', 'Rph[3,1]', 'Ra[3,1]', 'Rc[3,1]', 'Re[3,1]', 'Rph[4,1]', 'Ra[4,1]', 'Rc[4,1]', 'Re[4,1]', 'Rph[3,2]', 'Ra[3,2]', 'Rc[3,2]', 'Re[3,2]', 'Rph[4,2]', 'Ra[4,2]', 'Rc[4,2]', 'Re[4,2]', 'Rph[4,3]', 'Ra[4,3]', 'Rc[4,3]', 'Re[4,3]')) 
# Cholesky paths - off-diagonal
Conf3	<- mxCI(c('sta2[2,1]', 'stc2[2,1]', 'ste2[2,1]', 'sta2[3,1]', 'stc2[3,1]', 'ste2[3,1]', 'sta2[4,1]', 'stc2[4,1]', 'ste2[4,1]', 'sta2[3,2]', 'stc2[3,2]', 'ste2[3,2]', 'sta2[4,2]', 'stc2[4,2]', 'ste2[4,2]', 'sta2[4,3]', 'stc2[4,3]', 'ste2[4,3]')) 
# Cholesky paths - diagonal
Conf4	<- mxCI(c('sta2[1,1]', 'stc2[1,1]', 'ste2[1,1]', 'sta2[2,2]', 'stc2[2,2]', 'ste2[2,2]', 'sta2[3,3]', 'stc2[3,3]', 'ste2[3,3]', 'sta2[4,4]', 'stc2[4,4]', 'ste2[4,4]')) 
Conf5	<- mxCI(c('h2', 'c2', 'e2'))
```

## Estimation

```{r ACE model estimation}
# all parameters to be estimated 
pars <- list(pathA, pathC, pathE, covA, covC, covE, covP, StA, StC, StE, matI, rph, rA, rC, rE, MeanG, estVars, matIsd, Sta, Sta2, Stc, Stc2, Ste, Ste2
             )

# add these to the model for MZ and DZ with the matrices we have created
modelMZ	<- mxModel(pars, covMZ, dataMZ, objMZ, fitFunction, name = "MZ")
modelDZ	<- mxModel(pars, covDZ, dataDZ, objDZ, fitFunction, name = "DZ")

# fitting
minus2ll <- mxAlgebra(expression = MZ.objective + DZ.objective, name = "m2LL")
obj <- mxFitFunctionAlgebra("m2LL")

# full model
AceModel <- mxModel("ACE", pars, modelMZ, modelDZ, minus2ll, obj, Conf1, Conf3, Conf4)
```

```{r run ACE model}
# run ACE
AceFit <- mxRun(AceModel, intervals = TRUE)

# summary - this shows the position in the cells for each matrix 
AceSumm <- summary(AceFit)
AceSumm

# full list of A, C, and E estimates 
round(AceFit@output$estimate, 3)
```

## Output {.tabset .tabset-fade}

### Estimates of ACE

First we have the h^2^, c^2^, and e^2^ matrices. This is the proportion of individual differences explained by A, C, and E for each phenotype, so you can view these as percentages. 

These matrices are set up like this: 

|                  | age 5 | age 7 | age 10  | age 12 |
| ---------------- | ----- | ----- | ------- | ------ |
| Isolation age 5  |   a11 |    0  |     0   |     0  |   
| Isolation age 7  |   a21 |  a22  |     0   |     0  |   
| Isolation age 10 |   a31 |  a32  |   a33   |     0  |
| Isolation age 12 |   a41 |  a42  |   a43   |   a44  |

For the h2 matrix:

* Heritability is on the diagonal
* % of the phenotypic correlation that is due to genetics is on the off-diagonal
* The bivariate A, C, and E are on the off-diagonal
* Therefore, the off-diagonals are the contribution of ACE to the covariance between each time point 

```{r ACE model output h2, c2, e2}
# All h2, c2, e2 in one matrix 
round(AceFit$Est@result, 3)

# h2 
round(mxEval(ACE.h2, AceFit), 3) 

# c2
round(mxEval(ACE.c2, AceFit), 3) 

# e2
round(mxEval(ACE.e2, AceFit), 3) 
```

**Estimates of full ACE model at each time point (diagonal estimates):**

|                         |  Heritability  | Shared environment | Individual environment |
| ----------------------- | -------------- | ------------------ | ---------------------- |
| Social isolation age 5  | 0.563          |     0              |  0.437                 |
| Social isolation age 7  | 0.496          | 0.001              |  0.504                 |
| Social isolation age 10 | 0.489          | 0.002              |  0.509                 |
| Social isolation age 12 | 0.447          | 0.001              |  0.552                 |

* The C estimates here are all almost 0, this will probably mean that an AE model will be the best fit

**Shared effect estimates for ACE across time (off-diagonal estimates):**

* The % of the total variance that is due to shared genetic effects 

|                |  % Shared genetic effects  | 
| -------------- | -------------------------- | 
| Age 5 and 7    | 66%   (0.664)              |
| Age 5 and 10   | 79%   (0.787)              |  
| Age 5 and 12   | 85%   (0.846)              |  
| Age 7 and 10   | 74%   (0.744)              |  
| Age 7 and 12   | 72%   (0.720)              |  
| Age 10 and 12  | 68%   (0.680)              |

### Correlations between ACE factors

* Ra = the correlation between A1, A2, A3, and A4 - correlations between all the genetic factors
* Rc = the correlation between C1, C2, C3, and C4 - correlations between all shared environmental factors
* Re = the correlation between E1, E2, E3, and E4 - correlations between all individual environmental factors

For example:
![](RA.jpg) 

```{r ACE phenotypic correlations output}
# correlation between the A, C, and E factors - to what extend is variable one the same as variable two 
AceFit$ACE.Rph # total phenotypic correlation (including A, C, and E)
AceFit$ACE.Ra  # correlations between the a factors
AceFit$ACE.Rc  # correlations between the c factors
AceFit$ACE.Re  # correlations between the e factors
```

* The Rc estimate here is NULL - I'm assuming this is because the original estimates are 0 so this algebra would not work?


### Cholesky paths

Cholesky paths are directed for longitudinal data. A1 directly influences the next time point, and so on. 

For example:
![](sta2.jpg) 

The squared paths can be interpreted as the % of variance explained. This is equivalent to the correlations between factors, but now you are assuming that age 5 came before age 7 etc. All these paths are written in terms of square roots - so we have to square them in order to interpret them. This is the same for the A C and E paths, always interpreted as a^2^, c^2^ and e^2^. 

* The diagonal in the a^2^ matrix represents *new* genetic effects
* The off-diagonal in the a^2^ matrix represents the directed path to [2,1] represents A1 influence on isolation at age 7. 

```{r ACE cholesky paths output}
# A
#AceFit$ACE.sta
round(mxEval(ACE.sta2, AceFit), 3)

# C
#AceFit$ACE.stc
round(mxEval(ACE.stc2, AceFit), 3)

# E
#AceFit$ACE.ste
round(mxEval(ACE.ste2, AceFit), 3)
```

The diagonal of the sta^2^ matrix represents:

|         |  % new genetic effects  | 
| ------- | ----------------------- | 
| Age 5   |          56%   (0.563)  |
| Age 7   |          30%   (0.300)  |  
| Age 10  |          20%   (0.201)  |  
| Age 12  |          12%   (0.117)  |  

The off-diagonal of the sta^2^ matrix represents:

|                |  % Shared genetic effects  | 
| -------------- | -------------------------- | 
| Age 5 to 7     |             20%   (0.195)  |
| Age 5 to 10    |             15%   (0.151)  |  
| Age 5 to 12    |             14%   (0.136)  |  
| Age 7 to 10    |             14%   (0.137)  |  
| Age 7 to 12    |              6%   (0.064)  |  
| Age 10 to 12   |             13%   (0.130)  |

### Compare ACE and saturated model fit 

```{r compare the ACE and saturated model}
mxCompare(SatFit, AceFit)
```

**The ACE model fits significantly worse than the saturated model**. This may be because we are estimating C when this doesn't actually fit to our data. The next step is to run the AE model.  

***

# AE model 

As C was almost zero in our ACE model, we can consider dropping this to see if it improves model fit. 

## Estimation 

Labels for the c parameters are:

|                  | age 5 | age 7 | age 10  | age 12 |
| ---------------- | ----- | ----- | ------- | ------ |
| Isolation age 5  |   c11 |    0  |     0   |     0  |   
| Isolation age 7  |   c21 |  c22  |     0   |     0  |  
| Isolation age 10 |   c31 |  c32  |   c33   |     0  |
| Isolation age 12 |   c41 |  c42  |   c43   |   c44  |

```{r specify AE model}
# create the new model
AEModel	<-mxModel(AceFit, name = "AE"
                  , Conf3, Conf4
                   )

# set the C parameters to 0
AEModel	<- omxSetParameters(AEModel, 
                            labels = c("c11", "c22", "c33", "c44",
                                       "c21", "c32", "c43",
                                       "c31", "c42",
                                       "c41"), # labels ordered by diagonal (see above)
                            free = FALSE, 
                            values = 0) 
```

```{r run AE model output}
# run the model
AEFit <- mxRun(AEModel, intervals = TRUE)

AESumm <- summary(AEFit)
AESumm

# estimates
round(AEFit@output$estimate, 4)
```

## Output

### Estimates of A, C, and E, for each time point 

```{r AE model output h2, c2, e2}
# All h2, c2, e2 in one matrix 
round(AEFit$Est@result, 3)

# h2 
round(mxEval(AE.h2, AEFit), 3) 

# c2
round(mxEval(AE.c2, AEFit), 3)  # check that these are all now zero

# e2
round(mxEval(AE.e2, AEFit), 3) 
```

### Correlations between A, C, and E factors across all time points

```{r AE phenotypic correlations output}
# total phenotypic correlation (including A, C, and E)
AEFit$AE.Rph 

# correlations between the a factors
AEFit$AE.Ra  

# correlations between the c factors - check this is zero
AEFit$AE.Rc  

# correlations between the e factors
AEFit$AE.Re  
```

### Cholesky paths

```{r AE cholesky paths output}
# A
AEFit$AE.sta
round(mxEval(AE.sta2, AEFit), 3)

# C
AEFit$AE.stc
round(mxEval(AE.stc2, AEFit), 3)

# E
AEFit$AE.ste
round(mxEval(AE.ste2, AEFit), 3)
```

Here are the Choleksy estimates shown in a figure:
![](cholesky_AE.jpg) 

### Compare AE model fit to ACE and sat

```{r compare the AE fit to ACE and Sat}
mxCompare(AceFit, AEFit)
mxCompare(SatFit, AEFit)
```

* The AE model fits significantly better than the ACE model
* The AE model still fits significantly worse than the saturated model. 

***
